# 測試方式：

```bash
make run TEST=test-name
```

其中 test-name 代表應該存在這兩個檔案：
program/source/test-name.S
program/exp/test-name.exp

# exp 檔案的寫法：

exp 文件用于定义测试程序执行时每个寄存器写入操作的期望值。

## 格式：
```
寄存器编号 期望值
```

## 规则：
1. 每行一个期望值，按照程序执行的 **commit 顺序** 编写
2. 寄存器编号：1-31 (x1-x31)，不包括 x0
3. 期望值：32位十六进制数，格式为 8位十六进制 (如 00000001)
4. 以 # 开头的行为注释，会被忽略
5. 空行会被忽略

## 示例：
```
# 初始化测试
1 00000000    # x1 = 0
2 00000001    # x2 = 1
3 00000002    # x3 = 2

# 数据前递测试
6 0000000a    # x6 = 10
7 0000000b    # x7 = x6 + x2 = 11
8 0000000d    # x8 = x7 + x3 = 13
```

## 重要注意事项：
- **必须按照实际执行顺序编写**，不能按寄存器编号排序
- 如果同一个寄存器被多次写入，需要多次列出
- 测试框架会在验证完所有期望值后自动停止
- 只需要列出会写入寄存器的指令，store/branch 等不写寄存器的指令不需要列出
- tb_riscv_cpu.sv 的 MAX_COMMITS = 1024, 如果之後有更大的測試程式, 這裡要記得改

## 验证器如何判定一次“提交”
- 当 DUT 出现一次寄存器写回事件（`rd != x0` 且写回信号有效）时，记为一次提交
- 允许连续对同一个寄存器提交（即便值相同），因此 exp 中可以连续出现同一寄存器

## 值格式细节
- 采用 8 位十六进制数表示，不带 `0x` 前缀；大小写均可（如 `0000000a` 或 `0000000A`）
- 支持行尾内联注释：例如 `1 00000000  # x1 = 0`
- 允许空行与仅注释行，解析时会被忽略

## make run 传参与默认行为
- `make run TEST=<name>` 会自动传入：`+HEX=program/hex/<name>_prog.hex +EXP=program/exp/<name>.exp +CASE=<name>`
- 如果 exp 文件存在，会严格逐条比对提交序列；全部匹配后测试提前结束
- 若出现“未预期的提交”（超出 exp 的条目），会报错

## 进阶用法（可选）
- 生成 exp（从实际提交导出）：
```bash
vvp ./simv +HEX=program/hex/xor_prog.hex +CASE=xor \
  +DUMP_EXP=program/exp/xor.auto.exp +QUIET
```
  运行后会在 `program/exp/xor.auto.exp` 写出观测到的提交序列，可据此整理成最终的 `.exp`
- 此方法產生出的 exp **不一定** 是正確的內容, 因為 CPU 可能因為設計錯誤而導致產生錯誤的 exp
- 使用此方法必須非常謹慎

- 禁止某些寄存器被写回（例如禁止写 x0/x1/x2）：
```bash
vvp ./simv +HEX=... +CASE=... +EXP=... +FORBID_RD=0,1,2
```

- 在比较提交序列之外，额外断言若干寄存器的最终值：
```bash
vvp ./simv +HEX=... +CASE=... +EXP=... +EXPECT_REG=1:0x1,2:0x2,3:0x3
```

- 输出详略控制：
  - `+QUIET`：简化输出；`+SUMMARY`：只打印摘要；`+VERBOSE`：更多中间信息

## 常见问题与陷阱
- exp 必须对应“实际执行路径”的提交顺序，分支未执行到的指令不应写入 exp
- 同一寄存器多次写入要多次列出，顺序必须与执行一致
- 对含 load 的场景，若数据通路存在等待，提交只在真正写回的那个周期出现
